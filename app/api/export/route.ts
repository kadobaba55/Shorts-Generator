import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { exec } from 'child_process'
import { promisify } from 'util'
import path from 'path'
import fs from 'fs'

const execAsync = promisify(exec)

interface ExportRequest {
    videoPath: string
    trimStart: number
    trimEnd: number
    aspectRatio: '9:16' | '16:9' | '1:1'
    transform: {
        scale: number
        x: number
        y: number
    }
}

export async function POST(request: NextRequest) {
    try {
        const session = await getServerSession(authOptions)
        if (!session?.user) {
            return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
        }

        const body: ExportRequest = await request.json()
        const { videoPath, trimStart, trimEnd, aspectRatio, transform } = body

        // Clean up path to get absolute fs path
        const relativePath = videoPath.startsWith('/') ? videoPath.slice(1) : videoPath
        const fullInputPath = path.join(process.cwd(), 'public', relativePath)

        if (!fs.existsSync(fullInputPath)) {
            return NextResponse.json({ error: 'Input file not found' }, { status: 404 })
        }

        const outputDir = path.join(process.cwd(), 'public', 'output', 'renders')
        if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true })
        }

        const timestamp = Date.now()
        const outputFilename = `render_${timestamp}.mp4`
        const outputPath = path.join(outputDir, outputFilename)

        // Calculate filter complex for FFmpeg
        // 1. Trim
        // 2. Transform (Scale & Pan)
        // 3. Aspect Ratio Crop

        // Base resolution of the input clip (usually 1080x1920 based on previous logic)
        // We assume input is 1080x1920 (9:16) as generated by process route.
        // But let's be safe.

        // Transform Logic:
        // We need to zoom (scale) and pan (crop).
        // Since we are applying this on a potentially already padded 9:16 video.

        // Let's construct the filter chain.
        // First trim.
        const duration = trimEnd - trimStart
        // Use -ss and -t before input for fast seek if possible, but here we process.

        let filterComplex = ''

        // Step 1: Geometry
        // Scale first (Zoom)
        // iw*scale
        const zoom = transform.scale || 1
        const panX = transform.x || 0
        const panY = transform.y || 0

        // If input is 1080x1920. 
        // We zoom it: scale=iw*zoom:ih*zoom
        // Then we crop to target aspect ratio.

        let targetW = 1080
        let targetH = 1920

        if (aspectRatio === '16:9') {
            targetW = 1920
            targetH = 1080
        } else if (aspectRatio === '1:1') {
            targetW = 1080
            targetH = 1080
        }

        // We accept that the user positioned the video in the PREVIEW box.
        // The preview box in frontend matches the target aspect ratio.
        // The user moved the video inside that box.
        // transform.x and transform.y are pixels relative to the preview size? 
        // We need to map frontend pixels to video pixels.
        // Ideally frontend sends normalized coordinates or we assume 1080 width base.

        // Let's assume standard 1080 width for calculation simplicity if input is 9:16.
        // Or better, let's just use standard crop filter with pan.

        // crop=w:h:x:y
        // w, h are output size.
        // x, y are offset from top left.

        // But we first scale the VIDEO by zoom.
        // New dims: W' = W * zoom, H' = H * zoom.

        // Then we crop a 1080x1920 (or target size) window from it.
        // The center of the cropped window should be offset by panX, panY from the center of the scaled video?

        // Center of scaled video: CW = W'/2, CH = H'/2
        // Center of target window: TW/2, TH/2

        // TopLeftX = CW - TW/2 - panX (inverted? User drags video right -> we look left?)
        // If user drags video right (positive panX), the viewport moves left relative to video.
        // So crop X should decreases.
        // X = (iw*zoom - targetWidth)/2 - panX
        // Y = (ih*zoom - targetHeight)/2 - panY

        // FFmpeg filter:
        // scale=iw*zoom:-1,crop=targetW:targetH:(iw-ow)/2-panX:(ih-oh)/2-panY
        // Note: iw here refers to the output of scale filter.

        // Fix for 16:9 export from 9:16 source:
        // If we want 1920x1080 output from 1080x1920 input.
        // We probably need to scale input UP significantly if we want to cover it?
        // But user manually zooms. 

        // Let's trust user visual.
        // But wait, if target is 1920 wide (16:9), and input is 1080. 
        // If scale is 1, crop width 1920 is impossible on 1080 input.
        // So we must pad or ensure user zoomed enough. 
        // Or we scale the input so width is at least target width?

        // Actually, the preview in frontend for 16:9 shows the video fitting inside?
        // If we want to support "Export uses original" but cropped:

        // Let's construct a safe filter.
        // 1. Scale by zoom.
        // 2. Pad if necessary (to avoid crop error).
        // 3. Crop.

        const scaleFilter = `scale=iw*${zoom}:-1` // Keep aspect

        // We need to resolve the filter graph step by step or use complex expressions.
        // crop=w=1920:h=1080:x=(iw-ow)/2 - ${panX}:y=(ih-oh)/2 - ${panY}

        // IMPORTANT: panX/Y from frontend are heavily dependent on display size.
        // Attempt to interpret them as "video pixels" (assuming frontend uses 1080p base).

        const cropFilter = `crop=${targetW}:${targetH}:(iw-ow)/2-${panX}:(ih-oh)/2-${panY}`

        filterComplex = `[0:v]${scaleFilter},${cropFilter}[outv]`

        // Construct command
        // -ss and -t for trimming
        const ffmpegCmd = `ffmpeg -y -ss ${trimStart} -i "${fullInputPath}" -t ${duration} -filter_complex "${filterComplex}" -map "[outv]" -map 0:a -c:v libx264 -preset ultrafast -c:a aac "${outputPath}"`

        console.log('Rendering:', ffmpegCmd)
        await execAsync(ffmpegCmd)

        const outputUrl = `/output/renders/${outputFilename}`
        return NextResponse.json({ url: outputUrl })

    } catch (error: any) {
        console.error('Export error:', error)
        return NextResponse.json({ error: error.message }, { status: 500 })
    }
}
